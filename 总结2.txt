6-13:
      	上午：
		1. js书写位置
		2. 通过id获取元素
		3. 变量
			var 变量名; 
			var 变量名 = 值;
		4. 事件
		5. 函数
			函数声明 function 函数名( ){ }
			函数表达式 var func = function( ){ }
			匿名函数	function( ){ }
		6. 属性操作
			. [ ]
		7. style操作行间中的样式
-------------------------------------------------------------------------------------------------------
	下午：
		1. 元素上的属性 可读可写的
			id className value innerHTML src href
		2. 简易留言板
			value innerHTML
		3. 字符串
			单引号或双引号是成对出现
			'" 这是错误的
		4. 字符串拼接
			+
-------------------------------------------------------------------------------------------------------
6-14:	
	全天：
		1.window.onload = function( ){

			}
		2. if，流程控制语句
		3. if中的条件经过内部的转换会转成true/false
			成立就是真，不成立就是假
		4.true和"true" 是不一样的 一个是布尔值一个是字符串
		5.状态，用一个变量来标记一下元素的状态
		6.图片的src不能用来做判断
		7.动态的添加一些html结构，同时控制样式（参考6-14-afternoon，4-拼接样式的问题.html）
		8. cssText ----（add.style.cssText = 'background: red;width: 100px;height: 100px;border: 1px solid #000;';）
-------------------------------------------------------------------------------------------------------
6-15:
	全天：
		1.数组，类似于有顺序的仓库
		2.var arr = [ ] ;  直接量定义数组
		3.存值，存的值以逗号隔开，最后一个省略逗号
		4.取值，下标/索引值  是一个数字，下标是从0开始的，依次数数
		5.数组[ 下标 ]；
		6.数组的长度：（数组中存了多少个值），数组.length 
		7.数组的第一个值 arr[0]
		8.数组的最后一个值 arr[arr.length-1]
		9.例子：图片切换；	
			++ 自增加一 ，n++ n自己给自己+1，类似于 n = n+1
			 --  自减减一，n-- n自己给自己-1，类似于 n = n-1
-------------------------------------------------------------------------------------------------------
6-16:	
	全天：
		1.边界处理要放在 n++ 和 取值 中间	
		2.js定义字符串 单引号或双引号都可以 成对出现的
		3.在字符串中拼接中 （+）
			两边是数字，做加法运算，得到结果
			一边是字符串，不管另一边是什么值，都要做字符串拼接，会把另一边转成字符串
			从左边向右边运算的，提高运算优先级 加上( )
 		4.if的多种情况
				if(条件1){
					// 条件1成立，执行这里的代码
				}else if(条件2){
					// 条件2成立，执行这里的代码
				}else if(条件3){
					// 条件3成立，执行这里的代码
				}else{
					// 以上都不成立，走else
				}

		5.流程控制语句：for循环  重复做一些事情
		6.语法：
			for(1初始值;2条件;3自增){
				// 4循环体  把重复的代码放在这里
			}
			for循环的执行过程：
				1. 先执行初始值
				2. 条件是否成立
				3. 如果条件成立，执行循环体的代码
				4. 代码执行完成之后，自增
				5. 自增完成之后，
				重复步骤：2 3 4 2 3 4 2 3 4
				以上步骤中如果条件不成立，终止执行
				如果条件一直成立，会形成死循环，浏览器会卡死

		7.例子（生成100个div）
		8.   取消默认行为，在a标签的href中
                 	   	javascript:;
                    		javascript:void(0);

-------------------------------------------------------------------------------------------------------
6-19:
	全天：
		1.流程控制语句for  （重复做一些事情）
			break:  停止for循环
			contiune: 跳过本次循环，继续下次循环
		2. % 取模/取余  取两个数相除的余数 取整数，如果左边小于右边 取模后的值就是左边的值 
			隔行变色（ i%2 == 0）只要除以2 余数为0 都是偶数，是奇数行
		3.生成100个div;
			window.onload = function(){
				var box = document.getElementById("box");
				var n = -1;
				for( var i = 0; i < 100; i++ ){
					if( i % 10 == 0 ){
						n++
					}
			 	box.innerHTML += '<div style="left:'+(i%10)*50+'px;top:'+n*50+'px;">'+i+'</div>'
				}
			};

			window.onload = function(){
				var box = document.getElementById("box")
				for( var i = 0; i < 100; i++ ){
					box.innerHTML += '<div style="left:'+(i%10)*50+'px;top:'+Math.floor(i/10)*50+'px;">'+i+'</div>'
				}
			};
		4.九九乘法表
		5.获取元素
			通过id获取
				document.getElementById(id名字)
			通过标签获取 可获取到元素的子孙元素
				document.getElementsByTagName(标签名)
				元素.getElementsByTagName(标签名)				
			获取元素限制范围，
				document下获取，整个文档获取
				指定的而元素下获取
			通过class获取 可获取到元素的子孙元素
				document.getElementsByClassName(class名字)
				元素.getElementsByClassName(class名字)				
			通过css选择器获取元素
				document.querySelector(css选择器)  只能够获取符合选择器的第一个元素
				元素.querySelector(css选择器)
				document.querySelectorAll(css选择器)  获取符合选择器的集合
				元素.querySelectorAll(css选择器)
			知识点：
				通过
					document.getElementsByClassName
					document.getElementsByTagName
					获取到的是一个集合
					由获取指定class名字的元素组成的集合
					取集合的元素使用下标，下标从0开始
					获取集合的长度，length
-------------------------------------------------------------------------------------------------------
6-20:
	全天：
		1.调试：
			一个事件触发的时候出现问题了
				在事件触发函数中console.log()打印值
					打印成功：说明事件触发了
					没打印成功：
						单词是否拼对了
						元素是否获取对了

  		2.this 已经定义好的变量，this的值是不固定，根据执行的环境（上下文）决定this的值
			1. 在一对script标签中，this的值为window
				在浏览器中运行，执行的环境就是浏览器，浏览器中顶级对象为window
				window 是窗口对象/顶级对象
			2. this出现在函数中
				this的值取决于函数的调用,谁调用函数this就指向谁
				a. 直接调用 this => window
				b. 事件调用 this => 触发事件的元素		
		3.自定义属性：
			元素定义好的属性：style className innerHTML id src href value
			给元素自定义属性  获取一个元素都是一个对象、元素对象
			添加一条属性 
				元素.自定义的属性名 = 值
			对象是由多个名/值对组成的集合
				{
				     key:value;
				}
				key:属性名
				value: 属性值
		4.模拟单选，清除所有元素的样式，指定给点击的元素添加样式
		5.模拟多选，元素只关系自己状态的时候，需要单独的记录状态，不能共享状态了
		6. 变量不需要加引号，字符串加引号，字符串和变量拼接用+
		7. 给每一个元素绑定事件，for循环
		练习：4个V变化     图片擦擦擦
-------------------------------------------------------------------------------------------------------
6-21:
	全天：
		1.自定义属性
			系统已经定义好的属性
			只要是系统给我们提供的对象，都可以自定属性
				window 获取元素对象
			获取一个元素身上没有定义的属性，返回一个值undefined
		2.函数执行
			每一次函数被调用，函数代码块中的代码都要重新执行一次
			在函数中定义了变量，使用变量的时候，使用的是函数中定义的变量
				如果在函数中没有定义这个变量，会到全局找变量
					1. 找到了变量，就把变量存的值拿出来使用
					2. 找不到变量，会报错
		3.选项卡
			先清空所有的（样式、class）
			对应的元素添加（样式、class）
		练习：京东幻灯片
-------------------------------------------------------------------------------------------------------
6-22: 
	练习：星星评分
-------------------------------------------------------------------------------------------------------
6-23: 
	全天：
	 	1.当两个函数都要使用同一个变量的时候，定义在全局
		2.如果复用的函数有不同的地方，用传参解决
		3.checkbox，选中状态时    checked  为true
		练习：QQ列表   百度音乐
-------------------------------------------------------------------------------------------------------
6-26: 
	1.for循环中的this问题
	2.for嵌套
	讲解练习：QQ列表   百度音乐
-------------------------------------------------------------------------------------------------------
6-27: 
	全天：
		1.动态特性
			getElementsByTagName 有动态特性
				当向一个元素增加或删除元素，集合也会改变
			getElementsByClassName	

			但是用以下两个方法的时候，要等动态添加元素之后再获取（没有动态特性）
				querySelector
				querySelectorAll
			
		2.js数据类型：
			两大类型：1).基本（简单）数据类型	2).复合（引用）数据类型

				1).基本（简单）数据类型
					String => 字符串
						值：一对单引号或双引号包含的0个或多个字符串组成串
						"" 空字符串
						''
						'abc'
					Number => 数字
						整数
						浮点数
							0 1 2 3 4....
						取值范围：
							正无穷大 +Infinity
							负无穷大 -Infinity
					Boolean => 布尔值
						值： true false
					Undefined => 未定义
						值：undefined
							1. 定义一个变量没赋值，默认的值为undefined
							2. 找一个对象上不存在的属性，返回undefined
					Null  => 空
						值：null
							声明变量不确定要赋的值，可以使用null来占位
				2).复合（引用）数据类型
					Object => 对象
					值:是由0个或多个名/值组成的集合							
		3.内置的函数
			字符串 String
			数字 Number
			布尔值 Boolean
			对象 Object
		4.内置的函数，会打印function 函数名() { [native code] }
		5.检测数据的类型（使用： typeof 数据）
			一元运算符 typeof				
				typeof运算之后会返回一个字符串，这个字符串来表示数据的属于的类型
				typeof 数据 运算数据之后，可以得到以下字符串：
					string
					number
					boolean
					undefined
					object
					function
				数组和函数都属于对象的
					函数是可执行的一种对象，比较特殊
					js中函数属于一等公民
				注意：使用typeof检测null，返回的是object这个字符串
			+ 二元运算符
			三元运算符 条件 ? 条件成立走这里 : 条件不成立走这里
		6.数据类型转换：把一种数据的类型转成另一种类型
			把数据转成三种类型：
				Number
				String
				Boolean

			1).转成数字类型：
				Number(要转的数据)
					true => 1
					false => 0
					纯数字的字符串 => 转对应的数字
					undefined => NaN
					null => 0
					NaN => Not a Number 数字类型
						调用Number之后，不能转对应的数字，会用NaN来表示
						运算失败后，会用NaN表示
						和任何值比较都不相同，包括自己比较也不相同
						和任何值比较都返回false
					检测一个值是不是NaN
						可以使用NaN自己和自己不相同这个规则来比较
						isNaN(值)
							值是NaN，返回true
							值不是NaN，返回false
				parseInt(要转的数据) 得到的是整数
					要转的数据遇到不是数字的就返回数字部分
					数据的第一位不是数字，返回NaN
				parseFloat(要转的数据) 得到的是小数
			备注：
				函数 => 方法
			2).转成字符串类型
				String(要转的数据)
				''+数据
				toString()
				加号+：
					数字运算
					字符串拼接
						只要有一边是字符串类型，把另一边转成字符串类型的
				当转成字符串类型的时候，内部会调用一个方法，toString()
				对象是通过一个函数创建出来的。
			3).转成布尔值
				Boolean(要转的数据)
				! 取反，先把数据转成布尔值，取反
				!! 转成布尔值
				那些能转成false
					 '' 0 undefined null false NaN

		7.显式类型转换
			开发者自己手动调用方法进行转化
				String Number parseInt Boolean 
		8.隐式类型转换
			解析器为了运算方便，会隐式把一种类型转成另一种类型					
			+ 
		9.某一种数据类型会提供不同的方法，这些方法方便操作这类数据
			字符串.charAt(下标)
				查找字符串中指定下标的字符
		练习：输入QQ号码
-------------------------------------------------------------------------------------------------------
6-28: 
	全天：
		1.检测一个值是不是NaN
			isNaN(要检测的值)
				值为NaN 返回就是true
				值不为NaN 返回的是false
			会先调用Number方法转成数字类型
		2.字符串
			'' 一对
			"" 
			es6提供的
				`` 反引号 模板字符串（超级字符串）
				要渲染提供的数据，
					${数据}
			\ 传义符
			html结构有时候也称之为模板
		3.备注：字符串一旦定义，不能更改
		4.运算符		
			1).算术运算符
				+ 加、- 减、* 乘、/ 除、% 取模（求余数）、++、--
			2).赋值运算符
				=、+=、-=、*=、/=、%=
			3).关系运算符
				<、>、<=、>=、==、!=、===、!==
				比较后都会返回布尔值
				== 
					会把等号两边的值隐式转换，转成同一种类型的
					 	数字和字符串比较时候，字符串转成数字
					转成相同类型后，比较值是否相同
				===
					先比较类型，不相同返回false
					类型相同，比较值

				!= 不等于
				!== 不全等于
			4).逻辑运算符	
				&& 与、并且（左右两边的条件要同时满足才可以）
				|| 或、（左右两边的条件只需要满足其一就可以）					
				! 否 、
				三目运算符（不要嵌套太多三目）
					判断条件 ? 条件为true执行这里代码 : 条件为false执行这里代码
					条件为true，返回?后面的值
					条件为false，返回:后面值
		5.优先级
		6.求最大值	
		练习：找数据
-------------------------------------------------------------------------------------------------------
6-29: 
	全天：
		1.NaN
			not a Number
			数字类型
			不和任何值相等，包括自身
			和任何一个值元素，都会得到NaN
			和任意值比较，都是false

		2.isNaN(值)	（检测值是不是NaN）
			是 true
			不是 false
			
		3.函数调用（函数定义后，不会执行函数中的代码，只能调用才能执行）
			调用：函数名( )
		4.调用位置：
			函数声明调用（可以在函数声明之前和之后都可以调用）
			函数表达式调用（必须在赋值之后调用）
		5.函数参数
			在函数共用的时候，在调用函数的时候要执行不同的值，通过传参的形式解决
			形参：
				函数定义的时候，写在小括号中
					function func([形参1,形参2]){
	
					}
				形参的命名规则，要符合变量的命名规则
				形参就是在函数的内部声明的变量,默认值为undefined
				形参只能在函数中使用
			实参
				在调用函数时，写在小括号中
				会把这个实参赋值给形参
			形参和实参是一一对应的，以逗号隔开
		练习讲解：找数据
		练习：修改文本框的值      选项卡套选项卡
-------------------------------------------------------------------------------------------------------
6-30: 
	全天：
		1.实参的个数不固定，不确定的时候
			使用函数内部内置的变量：
			arguments 是函数实参的集合 类数组（类人猿）

			和数组有一些相同的特性，不具备数组的全部的特性
				相同特性：
					结构 [ ]
					length
					下标
				不相同：
					类数组没有数组的方法
		2.函数的返回值
			每一个函数被调用后都有一个返回值
			1. 默认为unefined
			2.使用关键字return
				只能在函数中使用
				函数调用后返回return后面的值
					如果return后没有值，函数返回值为undefined
				return之后的代码停止执行
		3.获取计算后的样式
			全局函数：
				getComputedStyle( )
			参数：
				是一个要获取计算后样式的元素
					getComputedStyle(元素)
			函数会返回一个对象
				对象是这个元素所有计算后的样式
		4.css方法设置
		练习讲解：修改文本框的值
-------------------------------------------------------------------------------------------------------
7-03: 
 	全天：
		1.封装补0
		2.标识符
			变量名，函数名
		3.作用域：
			用来管理标识符可以在哪里被访问的一套规则，或者说是标识符可被访问的范围

			全局作用域
				 在代码中任何地方都能访问到拥有全局作用域
				 1. 函数外定义的标识符拥有全局作用域
				 2. 不使用var定义的变量拥有全局作用域
						 声明变量一定要用var
				 3. 所有window对象上的属性拥有全局作用域
			局部作用域
				在js中只能使用函数来划分作用
				1. 使用var在函数内部定义的变量拥有局部作用域
		4.作用域链
			作用域嵌套的时候，查找标识符的规则
			作用域嵌套的时候是遵循一套严格的标识符查找规则的，内部作用域可以访问其父作用域以及父作用域的父作用域直到全局作用域的整个范围。说白了，就是函数内部作用域可以访问其自身和外部作用域的标识符，而外部作用域却不允许访问函数内部的标识符。
		5.提升
		预解析
			当js代码执行之前，会有一个预解析的过程，程序会把当	前作用域下的变量名和函数的声明提前解析
			js会把当前申明的变量名和函数提前当前作用域的最开始处理
			函数表达式
				只会把变量名提到当前作用域的最前面
				所以不能再函数表达式赋值前调用
		6.如果要声明多个变量，可以使用一个var，用逗号隔开。
		7.function fn( ){
			var c = d = 20;         // 赋值，先解析右边，给d赋值的时候还没有var，所有d这个变量就成了全局变量。
		}
		8.当一个函数申明嵌套另外一个函数申明的时候，就会产生一个闭包环境函数嵌套函数，内层函数可以访问外层函数中的变量
		练习讲解：商品累计     选项卡套选项卡
-------------------------------------------------------------------------------------------------------
7-04: 
	全天：
		1.尽可能少的定义全局变量，否则会造成全局变量污染
		2.闭包 模块化
		3.匿名函数自执行
		4.查找标识符是在定义函数的位置开始查找，不是在调用的位置查找
		5.eval（字符串 解析成代码运行 ，详见6-eval.html）
		6.封装$（作用是用来获取元素的）
			参数
				selector 传入的参数
				类型是一个字符串
				获取元素的字符串：
					#
					.
					tagName

				context 可选的
					限制获取元素的范围
					如果不传入，那么默认为document
		7.字符串.slice()  
			作用: 用来截取字符串
			参数：
				不传参 会返回整个字符串
				传参：
					参数是指定截取的下标
					指定一个参数
						从指定的下标截取到字符串的最后
					指定两个参数：
						截取的开始下标到结束下标 不包含结束下标
		8.字符串.trim()
			去除字符串前后空格  

		9.字符串.indexOf(字符串1)
			作用：搜索参数字符串1在字符串中首次出现的位置  
			返回值：
				搜索到指定的字符串1,返回下标
				没搜索到，返回-1
		10.定时器是什么
			javaScript中系统提供的函数
		11.定时器的作用
			每隔一段时间或者延迟一段时间执行一段指定的代码
		12.重复执行定时器
			每隔一段时间就会执行第一参数传入的函数
			setInterval(要执行的函数,间歇时间);
			setInterval(function(){},1000,[给函数传递的参数])
				间歇时间 毫秒
					1s = 1000ms
		13.延迟执行定时器
			延迟一段时间执行一个函数，仅且仅执行一次
			setTimeout(要执行的函数,延迟时间，[给函数传递的参数])
		14.什么时候使用定时器
			当需要隔一段时间重复执行一段代码时用 setInterval()
			当需要延迟一段时间执行一段代码时用 setTimeout()
		15.清除定时器
			关闭/停止定时器
-------------------------------------------------------------------------------------------------------
7-05: 
	全天：
		1.&& 
			左边不成立，返回左边的值
			左边成立，返回右边的值
		2.|| 
			左边不成立，返回右边的值
			左边成立，返回左边的值
		3.? :
		4.运算符运算结束后，都有结果			
			a ? b : c
			a成立返回b的值
			a不成立返回c的值
		5.定时器的最小值
			setTimeout 最小是 4ms
			setInterval 最小值 10ms
		6.当开一个定时器了，那不使用（达到目的了），一定要把定时器清掉
		7.广告下拉
		8.事件流 
			事件冒泡
				当触发一个元素的事件，这个元素以上的祖先节点都会触发对应的事件
		9.时间版运动；封装mTween
		10.时间戳 从1970年1月1日0时0分0秒到现在的毫秒数
			时间函数 Date
			Date.now();  获取的是ms
		11.回调函数 callback
-------------------------------------------------------------------------------------------------------
7-06: 
	全天：
		1.停止定时器
		2.一等公民  声明函数 函数作为值  函数还是对象
		3.数组.forEach()
			作用：循环数组的
		4.循环数组要做的事情：
			1. 拿下标
			2. 拿下标对应的
		练习：京东幻灯片无缝滚动
-------------------------------------------------------------------------------------------------------
7-07: 
	全天：
		1.定时器
			重复型定时器 
				setInterval(function,时间,[参数1,参数2,,...])
			延时型定时器
				setTimeout(function ,时间,[参数1,参数2,,...])

			定时的编号
				没开启定时器（调用函数），函数执行后返回这个定时器的编号

			清除/关闭/停止定时器
				clearInterval(定时器编号)
				clearTimeout(定时器编号)

		2.运动函数
			mTween()
		3.获取元素的$
			id class tagName css Selector
-------------------------------------------------------------------------------------------------------
7-10: 
	全天：
		1.日期对象
			用于处理日期和时间
		2.得到（创建）日期对象
			Date 构造函数
			new 一元运算符
			new 函数()  用来创建对象
		3.直接（字面）量
			1
			"abc"
			[ ]
			{ }
		4.构造函数的方式
			new Array( )
		5.每一个对象不是凭空就出现的，而是通过new运算符调用内部或自定义的构造函数来创建对象
		6.new Date( )
			参数：
				1. 不传参，创建的日期对象为执行到这句代码的本机当前时间
					默认是本机当前时间来创建时间对象
				2. 字符串
					new Date("年 月 日 时:分:秒")
					new Date("June 10,2013 12:12:12")
				3. 设置时间戳
					从1970年1月1日,00:时00分00秒 到获取日期对象的毫秒数
			日期对象不具有动态特性，获取最新时间，必须实时创建
		7.获取具体时间的方法
		8.抖动函数封装
		练习讲解：div依次下落     
-------------------------------------------------------------------------------------------------------
7-11: 
	全天：
		1.简易window10日历
			 a. 所处的月 真实的月份
    			 b. 当前月 推进的月份
        		2. 真实的月份为起点，不断推进向前推进月份
             			7月份 8月份 ... 12月份 
              			6 7 8 9 10 11 12 13 14
              			推进的会超过最大下标11            
            			设置当前月，下标超过了，那么自动会推到下一年
            			重新获取年和月
        		3. 当前月的 年和月
        		4. 获取当前月1号是周几
            			setDate(1) getDay( )
       	 	5. 计算当前月有多少天？？？
            			当前月+1推到下个月
            			设置setDate为0
		6.
			setFullYear() 	    设置年
			setMonth()    	    设置月  (月份从0开始计算)
			setDate()     	    设置日 
			setHours()   	    设置小时
			setMinutes()  	    设置分钟
			setSeconds()  	    设置秒钟
			setMilliseconds() 	    设置毫秒
			setTime()      	    获取1970-01-01 00:00:00到目前日期对象的时间差（单位:毫秒）
		练习讲解：图片翻页（图片滚动）
-------------------------------------------------------------------------------------------------------
7-12 	
	全天：
		1.图片滚动
		2.简易win10日历
		3.倒计时
          			未来的时间点，和现在不断变化的时间点，之间有个差值
         			利用这个差值，算出剩余天时分秒
          			var d = new Date();
        			d.setMonth(6);
        			d.setDate(20);
		4.charAt
			作用（方法返回字符串中指定位置的字符）				
			语法（string string.charAt(index)）			
			参数
				index（0 到 字符串长度-1 的一个整数）
			返回值（返回字符串）
				注意：如果index小于0或者大于等于字符串长度，返回空字符串
		5.indexOf
			作用（ 返回指定值在调用该方法的字符串中首次出现的位置 ）					
			语法（  number string.indexOf(searchValue [, fromIndex])   ）						
			参数
				searchValue
					一个字符串表示被查找的值
				fromIndex
					开始查找的位置，默认值为0
			返回值（返回数字）				
			如果存在返回位置，如果不存在返回-1
		6.lastIndexOf
			作用（返回指定值在调用该方法的字符串中首次出现的位置）						 
			语法（number string.indexOf(searchValue [, fromIndex])）						
			参数
				searchValue
					一个字符串表示被查找的值
				fromIndex
					开始查找的位置，默认值为0
			返回值（返回数字）						
				如果存在返回位置，如果不存在返回-1
		7.slice
			作用（方法提取字符串中的一部分，并返回这个新的字符串）						 
			语法（string string.slice(beginSlice[, endSlice])）						
			参数
				beginSlice
					起始位置
				endSlice
					结束位置，默认为最后一个字符的位置
					不包含结束位置的字符
			返回值（返回截取后的字符串）
		8.substring
			作用（截取指定位置之间的字符串）						 
			语法（string string.substring(indexStart [, indexEnd])）						
			参数
				indexStart
					截取的起始位置
				indexEnd
					截取的结束位置，默认为最后一个字符的位置
			返回值（返回截取后的字符串）							
		截取功能同slice
		9.substr
			作用（截取指定起始位置和长度的子字符串）					 
			语法（string string.substr(start [, length])）						
			参数
				start 
					截取的起始位置
				length
					截取的字符串长度，默认为起始位置到最后一个字符的字符长度
			返回值（返回截取后的字符串）
		10.split
			作用（ 通过一个指定的字符串把原字符串分割成一个数组）						
			语法（array string.split([separator] [, limit])）						
			参数
				separator
					分割符
				limit
					指定最多分割的数量，默认为全部
			返回值（返回一个数组）						
				当没有分割符的时候，整个字符串将作为一个整体保存到数组中				
		11.toLowerCase
			作用（把字符串全部转成小写）							 
			语法（string string.toLowerCase()）							
			参数
			返回值（返回转成小写的字符串）							
		12.toUpperCase
			作用（把字符串全部转成大写）							 
			语法（string string.toUpperCase()）							
			参数
			返回值（返回转成大写的字符串 ）
		13.arr.join()
			作用（将数组中的所有元素连接成一个字符串）							
			语法（string  arr.join([separator = ','])	）							
			参数
				separator
				可选，用于指定连接每个数组元素的分隔符。
				分隔符会被转成字符串类型；如果省略的话，默认为一个逗号。
				如果 seprator 是一个空字符串，那么数组中的所有元素将被直接连接。 
			返回值（拼接后的字符串）
							
		练习：文字搬运工      	文字查找和替换
-------------------------------------------------------------------------------------------------------
7-13 	
	全天：
		1.push( )
			作用（添加一个或多个元素到数组的末尾）						
			语法（number arr.push(element1, ..., elementN)）						
			参数（elementN	一个或多个元素）						
			返回值（数组的length）					
		2.unshift( )
			作用（添加一个或多个元素到数组的头部）						
			语法（number arr.unshift(element1, ..., elementN)）						
			参数（elementN	一个或多个元素）						
			返回值（新数组的length）						
		3.pop( )
			作用（删除数组最后一个元素）						
			语法（arr.pop( )）						
			参数（无）
			返回值（被删除的那一个元素）						
		4.shift()
			作用（删除数组第一个元素）						
			语法（arr.shift( )）						
			参数（无）						
			返回值（被删除的那一个元素）
		5.map( )
			作用（每个元素都调用一个提供的函数后返回的结果，放在新数组中）						
			语法（array array.map(callback[, thisArg])）						
			参数
				callback	在数组每一项上执行的函数，接收三个	
				callback参数：
				    	currentValue	当前项的值。
				   	index	当前项的索引（或下标）。
				  	array	数组本身。
					thisArg	可选参数		
					用来当作callback 函数内this的值。 
			返回值（新数组，新数组每一项是回调函数返回值）
		6.filter( )
			作用（根据回调函数的返回值过滤数组中的项，放在新数组中）						
			语法（array array.filter(callback[, thisArg])）						
			参数
				callback	在数组每一项上执行的函数，接收三个	
				callback参数：
				    	currentValue	当前项的值。
				   	index	当前项的索引（或下标）。
				  	array	数组本身。
					thisArg	可选参数		
						用来当作callback 函数内this的值。 
			返回值（返回过滤后的新数组）						
				如果返回值为true，则放入新数组中；
				如果返回值为false，则忽略						
		练习讲解：文字搬运工      文字查找和替换
-------------------------------------------------------------------------------------------------------
7-14 
	全天：
		1.函数自执行	
-------------------------------------------------------------------------------------------------------
7-17 
	全天：
		1.concat( )
			作用（将传入的数组或非数组值与原数组合并,返回合并后的新数组）						
			语法（array array.concat(value1, value2, ..., valueN)）						
			参数（valueN）
				需要与原数组合并的数组或非数组值.
			返回值（合并后的新数组）
		2.reverse( )
			作用（颠倒数组中元素的位置）						
			语法（array arr.reverse()）						
			参数（无）						
			返回值（颠倒顺序后的数组）						
			改变原来数组		
		3.join( )
			作用（将数组中的所有元素连接成一个字符串）						
			语法（string  arr.join([separator = ','])）						
			参数（separator）
				可选，用于指定连接每个数组元素的分隔符。分隔符会被转成字符串类型；如果省略的话，默认为一个逗号。如果 seprator 是一个空字符串，那么数组中的所有元素将被直接连接。 
			返回值（拼接后的字符串）
		4.slice( )
			作用（截取数组中一部分，并返回这个新的数组。）						
			语法（array	arr.slice([begin[，end]])）							
			参数 （begin，end）
				begin		起始位置
				end 		结束位置
				会把指定位置之间的值放在新数组中，不包含结束位置
			返回值（截取后的新的数组）					
			不影响原数组				
		5.splice( )
			作用（用新元素替换旧元素，以此修改数组的内容）						
			语法（array      array.splice(start, deleteCount[, item1[, item2[, ...]]])）						
			参数
				start		起始位置
				deleteCount	删除长度
				item		添加的内容
			返回值（由被删除的元素组成的一个数组）
		6.Array.from( )
			作用（把类数组转成一个新的数组）						
			语法（array Array.from(arrayLike[, mapFn[, thisArg]])）						
			参数
				arrayLike
					想要转换成真实数组的类数组
				mapFn
					生成的数组会经过该函数的加工处理后再返回
				thisArg	可选参数		
				用来当作callback 函数内this的值。 
			返回值（新的数组）
			
		7.Array.isArray( )
			作用（检测值是否是一个数组）						
			语法（boolean Array.isArray(obj)）						
			参数（obj）						
				需要检测的值。 
			返回值
				布尔值
				true，是一个数组
				false，不是一个数组								
		8.for in  循环  
			语法：
				for(变量 in 对象){
					// 循环体
				}					
				每一次循环的时候，都会把对象的key值赋值给变量
				break
				continue
			循环数组 for
			循环对象 for in      循环对象 ：（通过属性名那属性值），对象中的属性名，可以加""也可以不用加
			对象中的key类型是字符串
		9.for循环循环对象：
			对象要是连续的数字为key值
			手动的添加length
			对象没有length这个属性
-------------------------------------------------------------------------------------------------------
7-18
	全天：
		1.两个变量的值互换
			var a = "abc";
			var b = 30; 
			          1）.var c = a;
				a = b;
				b = c;
				console.log(a,b)

			          2）.a = [b,b=a][0]; // 先看右边
				console.log(a,b)
		2.递归：程序调用自身的编程技巧称为递归
			函数自己调用自己，形成递归
			当递归的时候，需要有一个条件让递归停下来
			只有函数执行完成之后才有返回值！
		3.冒泡排序
			需要几轮？数组的长度-1轮
			依次比较数组两个值，按大小条件交换位置，持续重复的比较，直到没有再需要交换为止，说明该数组排序完成了。
			以下是从小到大排序步骤：
				1. 比较数组中每一对相邻的元素，
					如果第一个比第二个大，就交换他们两个。
					从数组第一对到结尾的最后一对
				2. 经过一轮比较之后，会把最大的排到末尾						
				3. 针对所有的元素重复第一步，除了最后一个（因为已经是最大值）。
				4. 持续每次对越来越少的元素重复第一步，直到没有任何一对数字需要比较。
		4.设计一套数据结构
			一个里面，有标题，可能有下一级菜单
			{
				title: "第一级"   字段
				child:
			}

			[ ]
		5.快速排序
			从数组中拿出一个值，作为基准值 拿出数组的第一个
			把这个数组中，小于基准值的放在left数组中，大于基准值放在right这个数组中
			对left数组继续拿基准值，分左部和右部，重复以上两个步骤

			这种排序的思想是数组中的每个元素与基准值，数组中比基准值小的放在基准值的左边，形成左部；大的放在右边，形成右部；
			接下来将左部和右部分别递归地执行上面的过程：选基准值，小的放在左边，大的放在右边。。。直到排序结束。

				以下是从小到大排序步骤：
					1. 从数组张找出一个元素作为基准，pivot=数组.shift()
					2. 分区（Partition）：比基准值小的放左边，大的放右边，基准值(Pivot)放左部与右部的之间。
					3. 对左边和右边分区进行递归操作，重复以上步骤
		6.sort( )    //默认从小到大排序  默认是按字符串
			作用（对数组的元素进行排序）						
			语法（array arr.sort([compareFunction])）						
			参数
				compareFunction
					可选。用来指定按某种顺序进行排列的函数。
				如果省略，元素按照转换为的字符串的诸个字符的ASCII编码进行排序。 
			返回值（排序后的数组）
-------------------------------------------------------------------------------------------------------
7-19
	全天：						
		1.数组去重；
			var arr = [3,4,6,4,3,2,4,3,4]
			var newArr = [arr[0]];
			var num = 'no'
			for(var i=0;i<arr.length;i++){
				num = 'no'
				for(var j=0;j<newArr.length;j++){
					if(arr[i] == newArr[j]){
						num = 'yes'
						break;
					}
				}
				if(num == 'no'){
					newArr.push(arr[i])
				}
			}
			console.log(newArr)
		2.indexOf( ） 数组去重
			var arr = [3,4,6,4,3,2,4,3,4];
			var newArr = [arr[0]];
			for(var i=0;i<arr.length;i++){
				if(newArr.indexOf(arr[i]) === -1){
					newArr.push(arr[i])
				}
			}
			console.log(newArr)
		3.对象key值唯一性    ---------   （ 推荐使用方法）
			var arr = [4,5,4,2,1,2,1,8]
			var newArr = [ ];
			var obj = { };
			for(var i=0;i<arr.length;i++){
				if( !obj[ arr[ i ]] ){   // 说明这一项不是对象的key值
					newArr.push(arr[i])
					obj[arr[i]] = true;    // 把数组的这一项作为对象的key值
				}
			}
			console.log(newArr)
		4.Math
			Math 全局对象 处理数字
			Math.floor( ) 向下取整
			Math.ceil( ) 向上取整
			Math.round( ) 四舍五入
			Math.random( ) 随机数  0 - 1之间的数  不包含1

		5. x ~ y Math.round(Math.random()*(y-x)+x)
		console.log( Math.round(Math.random()*(100-10) + 10) );
-------------------------------------------------------------------------------------------------------
7-20   （DOM）
	全天：
		1.API接口
			API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数
			调用这些函数，实现自己的目的，无需知道实现原理
		2.DOM : Document Object Model
			处理可扩展标志语言（XML、HTML）的标准编程接口(API)
			赋予了操作页面的能力
		3. js  html标签=>文档树  DOM提供的很多的接口
		4.获取一个节点，对这个节点进行操作，节点是一个对象，操作这个对象就等同操作这个标签
		5.DOM是针对XML的扩展，应用于HTML的应用程序编程接口API，制定这些接口的目的是为了能以编程的方法操作这个 HTML 的内容
		DOM把整个应用程序界面映射为一个多层的节点结构，可以看做是一个文档树（或节点树），组成这个树的每一部分称之为节点，每一个节点都是一个对象。
		通过DOM提供的接口，允许开发人员可以很方便的删除、添加、替换、修改任何节点

		6.DOM节点：
			元素节点    每个 HTML元素       	 	nodeType    1        nodeName   标签名（全大写）
			属性节点    HTML元素的属性		nodeType    2        nodeName   属性名
			文本节点    HTML元素内的文本		nodeType    3        nodeName   #text
			注释节点    注释 <!---->		nodeType    8        nodeName   #comment
			文档节点    整个文档document		nodeType    9        nodeName   #document
		7.DOM类型：
			NodeType	   	Named Constant
			1		ELEMENT_NODE
			2		ATTRIBUTE_NODE
			3		TEXT_NODE
			4		CDATA_SECTION_NODE
			5		ENTITY_REFERENCE_NODE
			6		ENTITY_NODE
			7		PROCESSING_INSTRUCTION_NODE
			8		COMMENT_NODE
			9		DOCUMENT_NODE
			10		DOCUMENT_TYPE_NODE
			11		DOCUMENT_FRAGMENT_NODE
			12		NOTATION_NODE
		8.通过一个对象调用这些接口 document
		9.获取元素上的属性节点  attributes  元素上属性的集合
		10.获取一个元素下所有的子节点  childNodes
		11.节点之间的关系：
			包含是父子关系，并列是兄弟关系
			祖先节点：当前节点往上的所有节点
			子孙节点：当前节点往下的所有节点
			node.parentNode 			--- 获取父节点
			node.children 			--- 获取所有子元素节点
			node.childNodes			--- 获取所有子节点					
			node.previousElementSibling		--- 获取上一个兄弟节点
			node.nextElementSibling 		--- 获取下一个兄弟节点
			node.firstElementChild 		--- 获取元素中第一个子节点
			node.lastElementChild 		--- 获取元素中最后一个子节点
		12.
  			获取子节点
				element.childNodes 获取所有的子节点
				element.children   获取所有的子元素节点
			获取节点的父级
				element.parentNode
			获取兄弟节点
				上一个兄弟
					element.previousElementSibling
				下一个兄弟
					element.nextElementSibling
			获取元素的第一个子节点
				element.firstElementChild
			获取到元素的最后一个子节点
				element.lastElementChild
-------------------------------------------------------------------------------------------------------
7-21   （DOM）
		1.在行间中写自定义的属性获取一个元素之后，并不会添加在获取这个元素对象上
		2.在元素行间中添加一个自定义属性
			1. 设置行间属性
				element.setAttribute(key,value)
			2. 获取行间属性
				element.getAttribute(key)
			3. 删除行间属性
				element.removeAttribute(key)
		3.在行间中已data-开头的自定义属性，获取一个元素之后，会放在dataset这个对象上
		4.<input  type="button"  value="测试属性"  id="btn"  b="30"  data-miaov="custom"  data-miaov-ketang-custom="测试"/>
			console.log(btn.dataset);  	//DOMStringMap {miaov: "custom", miaovKetangCustom: "测试"}
			console.log(btn.dataset.miaov);  	//custom
			console.log(btn.dataset.miaovKetangCustom);	//测试
		5.对DOM节点操作
			获取
			创建
			删除
			修改
			替换

		6.innerHTML 赋给innerHTML的值是一个字符串结构
		7. 
			创建一个元素
				document.createElement ( "标签名" )
			向一个元素追加一个子节点
				element.appendChild ( 元素 );
					返回值是追加的元素
			往一个节点的指定子节点前边插入一个节点
				element.insertBefore ( newElement,childNode2 )
					newElement    要插入的元素
					childNode2     被插入的目标元素
					参数：
						newElement必须要存在，并且是一个节点（node）
						childNode2可以不存在，insertBefore功能就类似于appendChild
					把newElement插入到childNode2前边
			 替换指定的子节点
				element.replaceChild(node,childNode)
					node用来替换的节点，childNode被替换的子节点
      				两个参数都必须写。
      			 删除指定的子节点
      				element.removeChild(childNodes)
      				childNode.remove()   把自己从父节点删除
		8.懒加载：
		<img src="./img/1.jpg" _src="./img/2.jpg" id="img">
		<script>
			var img = document.getElementById("img");
			document.onclick = function (){
				var src = img.getAttribute("_src");
				if(src){
					img.src = src;
					img.removeAttribute("_src");
				}
				
			};
		</script>

		9.
			element.cloneNode( );
				克隆一个节点
					true：克隆元素和元素包含的子孙节点
					flase：克隆元素但不包含元素的子孙节点
				默认是false
				不能克隆事件
-------------------------------------------------------------------------------------------------------
7-24
	全天：
		居中的元素宽高不固定				
		元素的left值和top值
		元素的left值 = (可视区的宽 - 元素所占的宽）/2
		1. 可视区的宽/高
			document.documentElement 就是html元素
			document.documentElement.clientWidth
			document.documentElement.clientHeight
		2. 元素所占的宽/高
			element.clientWidth/clientHeight  不包含border
			element.offsetWidth/offsetHeight  包含border
		浏览器改变尺寸触发一个事件
			window.onresize = function(){}
		出现滚动条，滚动条向下拉，依然让box出在中心，需要加上页面被卷去的高度				
		浏览器滚动条滚动的时候触发的事件
			window.onscroll = function(){}
		页面滚动的距离
			y轴的：
				document.document.scrollTop  ie和ff放在html
				document.body.scrollTop      chrome放在body
			x轴的：
				document.document.scrollLeft
				document.body.scrollLeft

		*定位父级
			element.offsetParent
			可获取到最近的定位父级，如果没有定位元素，定位父级默认为body
		偏移量
			offsetLeft 相对于定位父级左边的偏移量	
			offsetTop 相对于定位父级上边的偏移量
		最好是把父级和自己都加上定位

		元素相对于浏览器左边和上边的距离
			element.getBoundingClientRect()
			返回对象：
				width  元素占的width，包含border和padding
				height
				left
				top
				right  元素的最右边到浏览器左边的距离
				bottom 元素的最下边到浏览器上边的距离 
		不占位置的元素
           			 offsetWidth/clientWidth/offsetLeft/getBoundingClientRect
           			 都不能获取到真实占位的值，获取的值都为0
-------------------------------------------------------------------------------------------------------
7-26





-------------------------------------------------------------------------------------------------------
7-27
	全天：
		1. form作用：   提交数据				
		2. method:    提交方式   get   post
			http://www.miaov.com/?userName=wangyun&password=123
			表单控件上name是和后端进行约定的，代表特殊意义
		3. document.forms 页面中表单的集合
			console.log( document.forms[ 0 ] );
		4. 使用name找表单控件
			console.log( document.forms[ 0 ].userName );
		5. onchange  value变化时会触发这个事件           （参考7-27 ------------ 2.html）
			document.forms[ 0 ].select.onchange  = function ( ){
				console.log( this.value );	
			}
		6. onchange使用在input为text时要注意	   （参考7-27 ------------ 3.html）
			在获取焦点改变value值不会触发的
			失去焦点value发生变化才会触发
			document.forms[ 0 ].userName.onchange  = function ( ){
				console.log(this.value);	
			}
		7. oninput 在输入的过程中发生变化，就会触发    （参考7-27 ------------ 3.html）
			document.forms[ 0 ].userName.oninput  = function ( ){
				console.log(this.value);	
			}
		8. 通过js来控制			（参考7-27 ------------ 4.html）
			提交表表单的方法      form.submit( )
				btn.onclick = function ( ){
					if(document.forms[ 0 ].userName.value === ' '){
						return;
					}
					document.forms[ 0 ].submit( );	
				};
			重置表单的方法         reset( )
  				resets.onclick = function ( ){
					//console.log(document.forms[ 1 ]);
					document.forms[ 1 ].reset( );	
				};
		9. 浏览器的默认行为
			不用写任何js代码，浏览器就有的一些行为
				a标签跳转链接
				选中 文字
			默认行为触发和开发者监控对应的事件
				监控对应的事件先触发,可以在触发默认行为之前取消默认行为
		10. <a id="linkA" href="http://www.miaov.com">miaov</a>
			linkA.onclick = function ( ){      
				console.log( 123 );    
				return false;	//点击a时不会跳转到页面了
			};
		11.BOM --- 浏览器对象模型
			Browser Object Model，简称BOM
			关于如何控制浏览器的一些东西

		12. window
			顶级/全局对象
				全局声明的变量和函数都会放在window上
			既是通过js访问浏览器窗口的接口
		13. window.open( );
			 一打开页面，就打开新窗口
				ff和chrome因为安全限制，做一个限制
				ie直接打开新窗口
		      	点击页面，打开新窗口
				直接打开新窗口
			在ie下必须等页面加载完了在给document绑定事件
		14. window.open('http://www.miaov.com',"_blank","width=500,height=500,left=400,top=100");
		     <iframe width="1000" height="1000" name="custom"></iframe>
		     window.open('http://www.baidu.com',"custom"); // 指定ifram的名字	
			 window.open( );打开一个新窗口
			参数：
				1.指定要打开的页面地址。
				2.打开方式 ： _blank     _self（当前窗口）    ... iframName
				3.浏览器的窗口特征 （宽，高，窗口位置等）
					设置width、height、left、top
		15. window.close( );	
			一打开页面，就关闭窗口
				ff和chrome直接关闭
				ie下 询问是否关闭
			点击页面，关闭窗口
				chrome直接关闭
				ff不关闭
				ie下 询问是否关闭
		16. 用户代理信息    window.navigator.userAgent
		17. 内核
			https://jingyan.baidu.com/article/5553fa82d50eaf65a339346c.html
		18. http://www.miaov.com:80/home/index.html?miaov=ketang&video=study#vip=123&videoId=456
			https/http:// 		===>	protocol 		传输协议
			miaov.com 		===>	host name 	主机名
			80  			===>	port		端口   
			home/index.html 		===>	path 		路径
			?miaov=ketang&video=study ===>	search 		查询数据
			#vip=123&videoId=456 	===>     hash 		锚点
		19.  <a href="#test">定位</a>
		      <div style="margin-top: 3000px;height: 1000px;" id="test">定位到这里</div>
		20. window.location
			console.log( window.location );     // 地址栏中的信息
			console.log( window.location.href );     // 获取完整地址
			改变地址栏的地址	    window.location.href = 'http://www.miaov.com'
			console.log( window.location.search );    // 查询的数据 ?到#之间的数据，包含问号
			console.log( window.location.hash )    //哈希 锚点
		21. 改变search值会刷新页面
			changeSearch.onclick = function (){
				box.style.background = 'blue';      //点击changeSearch时，添加的box的背景会闪；

				window.location.search = 'leo'; 	//同时查询的数据    ？leo
			}

		22. hash之后改变不会刷新页面
			changeHash.onclick = function (){
				box.style.background = 'blue';        //点击changeHash时，添加的box的背景不会闪；

				window.location.hash = 'user=leo';	  //哈希 锚点     =》 #user=leo
			}
-------------------------------------------------------------------------------------------------------
7-31
	全天：
		1.一个元素的同一个事件不能绑定两个事件处理函数
		2.DOM1级，把事件处理函数赋给元素上跟事件有关系的属性
		3.DOM2
			element.addEventListener(
				事件名（不加on），
				事件处理函数（侦听器），
				[是否捕获]
			)
		4.事件
			javascript与HTML之间的交互是通过事件实现的。事件就是文档或浏览器窗口发生的一些特定的交互瞬间。
			我们所能做的就是使用事件处理函数来侦听一个事件，当事件触发时，执行事件处理函数。        
		5.当在一个元素上触发一个事件的时候，系统获取找元素上个这个事件有关系的属性，属性对应的值如果是一个null，不执行；如果是一个函数，就把函数执行了。
		6.绑定事件处理函数
			element.addEventListener(
				事件名（不加on）,
				事件处理函数|侦听器,
				[是否捕获]
			)
		7.解绑事件处理函数
			element.removeEventListener(
				事件名（不加on）,
				事件处理函数|侦听器,
				[是否捕获]
			)
		8.元素对应的事件的事件处理函数，在绑定的时候使用的是匿名函数，解绑的时候，要给匿名函数起一个名字
		9.事件对象
			在触发DOM上的某个事件时，会产生一个事件对象event。这个对象中包含着所有与事件有关的信息。包括触发事件的元素，事件的类型以及其他与特定事件相关的信息。
		10.获取事件对象
			事件对象作为事件处理函数的第一个参数，在函数中定义形参接收
		11.在事件触发的时候，会执行后面的函数，执行函数的同时回传一个参数过来，这个参数就是事件对象，我们多能做的就是在这个函数上定义形参来接收。
		12.在拖拽过程中，不断计算left值和top值，赋给被拖拽的元素
			三大事件  mousedown mousemove  mouseup
			鼠标到视口的距离
				x轴  ev.clinetX
				y轴  ev.clientY
			算一下鼠标到元素左边的距离
				disX = 鼠标摁下时候鼠标的clientX - 元素到左边的距离offsetLeft
			在移动过程中元素的left值
				left = 鼠标在移动过程中的clientX - 鼠标到元素左边的距离（disX）
-------------------------------------------------------------------------------------------------------
8-01
	全天：
		1.当一个事件触发后，从触发事件的这个元素开始，沿途经过的祖先节点都会出触发对应的事件，至到一个不确定的元素（window结束）
		2.事件流描述的是从页面中接收事件的顺序。
		3.事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程即DOM事件流。
		4.事件流的三个阶段：
			1. 捕获阶段  从window开始，到事件触发的具体元素，沿途经过的元素都会触发对应的事件
			2. 目标阶段  事件触发的具体元素上
			3. 冒泡阶段  从事件触发的具体元素开始，到window结束，沿途经过的元素都会触发对应的事件
		5.以on开头的这种事件只能检测到冒泡阶段
		6.看一下捕获阶段
			element.addEventListener(
				事件名,
				事件处理函数，
				[是否捕获]
			)
			第三个参数：
				true  捕获阶段
				false 冒泡阶段  默认
		7.有一个逻辑和祖先的节点逻辑正好相反，如果冒泡的话。最后会触发祖先节点的事件处理函数
		8.阻止冒泡        ev.stopPropagation();
		9.事件冒泡的好处：
			<input type="text" id="message" /><input type="button" id="btn" value="提交">
			<ul id="list">
				<li>123 <input type="button" value="X"> </li>
				<li>123 <input type="button" value="X"> </li>
			</ul>
			<script>
				var inputs = list.getElementsByTagName("input");
				list.onclick  = function (ev){				
					if(ev.target.nodeName === 'INPUT'){   // target是事件源
						console.log('我触发了');
						console.log(ev.target);	
						ev.target.parentNode.remove();
					}
				}
				btn.onclick = function (){
					list.innerHTML += `<li>${message.value} <input type="button" value="X"> </li>`;
				}
			</script>
		10.浏览器的默认行为是指非js添加的默认就有的一些功能
			例如：右键菜单，图片/文字/链接的拖拽
			这些浏览器默认提供的功能有时我们并不需要，反而会带来一些小问题		
				如：拖拽应用中，如果拖拽目标是图片则无法实现拖拽效果
				如：自定义右键菜单功能在我们触发右键事件时系统默认的菜单也会出现
		11.取消默认行为
			return false 只能用在以on开头的
			addEventListener绑定的事件处理函数取消默认行为
				ev.preventDefault();
		12.oncontextmenu右击时候，菜单出现的那一刻才触发的事件，这个事件不是右击事件，右击事件是onclick
		13. ev.clientX/clientY 相对于视口
		     ev.pageX/pageY 相对于页面

-------------------------------------------------------------------------------------------------------
8-02
	全天：
		1.在中心点移动
			document.onmousemove = function (ev){
				box.style.left = ev.clientX - box.clientWidth/2 + 'px';	
				box.style.top = ev.clientY - box.clientHeight/2 + 'px';	
			};	
		2.冒泡
			在给父级绑定事件后，当操作一个子级的时候，由于冒泡机制，不得不触发父级的事件，给子级绑定对应的事件阻止冒泡
				ev.stopPropagation( );
		3.事件源
			当一个元素触发了某个事件，会有一个冒泡的机制，沿途经过的这些元素都会触发对应的事件，要找事件源（从哪个元素开始触发的事件），ev.target
		4.ondblclick  （鼠标双击事件）
		5.mouseenter和mouseleave不冒泡
		6.当鼠标中键滚动触发一个事件
			chrome和ie
				onmousewheel （ 滚动触发的事件）
			ff:
				DOM3级事件 以DOM开头
				DOMMouseScroll （ 滚动触发的事件）

				ie下怎么绑定多个事件处理函数？兼容性再说！
				事件对象 ie低版本下，事件对象不是事件处理函数的第一参数
	
				ie9以上 chrome和ff，作为事件处理函数的第一个参数
				ie6,7,8 作为全局的变量，event
		7.alert(event);  // 在ie下系统已经定义好了这个变量，chrome也支持，ff全局类有定义这个event变量
		8.ie和chrome下：
				e.wheelDelta
				上滚 150 下滚 -150
		ff
				e.detail
				上滚 -3 下滚 3
		9.visibility: hidden; （隐藏占位）
-------------------------------------------------------------------------------------------------------
8-03
	全天：
		1.函数也是个对象，有方法和属性				
			函数.call()
				1. 直接会执行这个函数
				2. 概念这个函数this的指向
				3. 要给执行的函数传参数
			函数.call()的参数说明：
				第一个参数：函数this的值
				从第二个开始，就是给函数传的参数
			call()
				函数.call():可改变函数的this指向
					1. 函数下的一个方法
					2. 函数调用call这个方法的时候，就直接调用了这个函数
				参数：
					第1个参数 
						改变this指向的那个值
						如果设置了null或者undefined，
						函数中的this仍然指向window						
					从第二个参数开始，依次传入的参数，
					就是给用call来调用的那个函数传入的实参
			函数.apply()
				作用和call一模一样
				唯一不同的是给函数传参的形式不同
					apply 第二个参数是数组或类数组
					call 从第二个参数开始是给函数传的参数
			apply()
				函数.apply():可改变函数的this指向
					1. 函数下的一个方法
					2. 函数调用call这个方法的时候，就直接调用了这个函数
				参数：
					第1个参数 
						改变this指向的那个值
						如果设置了null或者undefined，
						函数中的this仍然指向window						
						第二参数是一个数组或类数组
						数组中依次的每一项就是传入的实参
						数组里面的每一项对应调用函数的形参
				this的值是一个对象，如果改成是简单值，内部会调用值对应类型的函数转成对象
		2.焦点事件会在页面元素获取和失去焦点触发
			获取焦点：
				1. 点击获取
				2. tab键获取焦点
				3. 方法获取焦点
					元素.focus();
			onfocus
				获取焦点时触发的事件 
			onblur
				失去焦点时触发的事件 
		3.使用键盘会触发键盘事件
			onkeydown
				按下键盘任意键触发 
				按下不松开，会一直触发
			onkeyup
				释放键盘上键时触发
			ev.keyCode
				键盘上键对应的的编码
		4.altKey、ctrlKey、shiftKey  按着相对应的键，对应的值就为true，否则为fasle
		5.取绝对值
			Math.abs(值)
		取最大值
			Math.max(值1,值2,值3....)
		取最小值
			Math.min(值1,值2,值3....)

-------------------------------------------------------------------------------------------------------
8-22-23
	ES6
		1.let声明变量
			1.let不允许在同一个作用域下声明已经存在的变量
			2.let不存在变量提升，必须声明后才使用
			3.使用let会形成块级作用域，也就是说用let声明的变量，只在命令所在的代码块内有效
			4.在for循环中，如果用let来进行变量的初始化，那么在循环语句内是一个父作用域，在循环体之中是一个子作用域
				可以类比函数理解，每次执行for循环，都创建一个执行环境
				每次声明这个i，i的初始值是上次执行的结果
				当点击li时，会去找父作用域里的i
				与var不同的是，for循环里var初始的值是在全局作用域都可访问的
			花括号里用let声明变量，该花括号形成块级作用域
			5.使用let声明的变量不会挂载在window身上，用var声明的变量会自动挂载在window身上
		2.const
			声明的是常量
			1.同样有let的1、2、3条特点
			2.如果储存简单的数据类型时不可改变其值，否则会报错
			3.如果储存的是引用类型（对象、数组、函数），引用不可被改变，引用类型里的数据可以变化
			引用类型，引用的是地址
		重新赋值（let可以，const不可以）
		如果储存简单的数据类型时不可改变其值，否则会报错
		如果储存的是引用类型（对象、数组、函数），引用不可被改变，引用类型里的数据可以变化
		3.Object.defineProperty( ) 方法( 定义属性的方法 )
			Object.defineProperty(obj, prop, descriptor)
			三个参数
				1.obj 对象本身
				2.prop 对象里的属性
				3.descriptor 将被定义或修改的属性的描述符。
					数据描述符
						数据描述符是一个拥有可写或不可写值的属性
					存取描述符
						存取描述符是由一对 getter-setter 函数功能来描述的属性

		4.descriptor描述符的分类
			分为
			 数据描述符
		 		数据描述符是一个拥有可写或不可写值的属性
			存取描述符
		 		存取描述符是由一对 getter-setter 函数功能来描述的属性
		 	描述符必须是两种形式之一；不能同时是两者。

			数据描述符和存取描述符均具有以下可选键值：
		 		value
					属性值是什么
 						默认为undefined
 				writable
					属性值能不能重新改写
 						true，可以，false不可以，默认为false
 				enumerable
 					属性值是否可被枚举
						true，可以，false不可以，默认为false
 				configurable
 					是否可被删除
 						true可以，false不可以，默认为false

		如果用Object.defineProperty()定义的属性原来不存在，那么定义一个新属性
		如果用Object.defineProperty()定义的属性已经存在，那么操作原有的属性
		5.变量的解构赋值
			概念
				ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）
				本质上是一种匹配模式，只要等号两边的模式相同，那么左边的变量就可以被赋予对应的值
			分类
				数组的解构赋值
					按顺序一一对应
				对象的
					没有顺序限制，按key值一一对应
				基本类型的
					字符串
				只要某个值可以被循环，就可以进行解构赋值
			默认值
				没有赋值 就按默认值
		6.箭头函数:( ) => { }
			 1个形参    
	 			  let fn = a => a;  // 函数执行后return a
			多个形参
				  let func = (a,b) => a*b
			没有形参
				let func2 = () => ({a:1}); // 如果
		 		右边是一个对象，要用小括号抱起来，否则会解析为函数体；函数执行后return {a:1}对象
		 		let func3 = () => {
		 			// 函数体
		 			console.log(123);
		 			console.log(123);
		 			console.log(123);
		 			return ;
		 		}
		 		//如果函数体里有多条代码，那么要加{}括起来

		7.箭头函数的this
			箭头函数中的this，是在定义时候决定的，拥有定义作用域的this，和调用的位置无关
		8.暂时性死区
			在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
		9.绑定this(就是把函数中this指向指定的值)
			立马执行了：
				函数.call( )
				函数.apply( )
			不执行函数，改this值
				函数.bind( );    用bind可以不立即执行函数改变this
		<script>
			function fn(){
	 			console.log('我被调用了')
	 			console.log(this);
	 		}

	 		function bind(fn,oThis){
	 			// 调用bind之后，会返回新函数，在新函数中调用改变this的函数
	 			function oBind(){
	 				fn.apply(oThis)
	 			}
	 			return oBind
	 		}
	 		// 改变fn中this的指向，不立马调用函数
	 		var f = bind(fn,[1,2])
	 		f()

			document.onclick = function (){
	 			function fn(){
	 				console.log('被执行了');
	 				console.log(this)
	 			}
	 			let f = fn.bind(this) //返回新的函数
	 			setTimeout(f,1000)
	 		}
		</script>

		10.try-catch (报错了，不影响后续代码继续执行)
		11.字符串的扩展
			1.repeat方法返回一个新字符串，表示将原字符串重复n次
				参数：
					 如果是小数，那么是向下取整
					 如果是0，重复0次，也就是空
					 如果是-1~0，按0算，js里-0 === 0；
			2.includes(参数：要查找的字符串 )：返回布尔值，表示是否找到了参数字符串。
		12.数值扩展
			非ES6，parseInt，parseFloat等方法，是放在window上，是个全局函数
			ES6里把parseInt，parseFloat等方法放在Number上了
			Number.parseInt('100px')
			Number.isNaN('100px')
		13.数组的扩展
			1.创建数组
				var arr = [ ];
				var arr2 = new Array( );
				var arr2 = Array.of(3);   //修复上面的bug，参数里面只写一个值，不是默认是数组的长度
			2.添加或修改数组里的值
				使用下标添加值 或者push;
				new Array( )创建时直接添加	
			new Array( )里面只写一个值，默认是数组的长度，写两个值以及以上 才作为数值放入数组

			3.find（找到符合数组中首次符合条件的）
				参数：item index arr
				不改变原数组
				返回一个值（找到数组中首次符合条件的）
			4.Array.from ( )方法
				 Array.from ( )
			 	 作用
			 		类数组转成数组
					只要是可以循环的对象，都可以用Array.from()转成数组
			 	语法
			 		array Array.from(arrayLike[, mapFn[, thisArg]])
			 	参数
			 		arrayLike
		 				想要转换成真实数组的类数组
			 		mapFn
			 			生成的数组会经过该函数的加工处理后再返回
		 				类似于map，记得要return
			 		thisArg	可选参数
			 			用来当作callback 函数内this的值。 
			 	返回值
			 		一个新的数组
			5.遍历器
				 for of
					直接循环出value值
				 for in
					循环的是key值
			6.数组的includes( );
				第一个参数：要查找的内容
				第二个参数：开始查找的位置
				返回值
					true
					false
				用indexOf( )的问题：会对NaN产生误判
				用includes()，不会对NaN产生误判
		16.对象的扩展
			Object.is( )
				1.ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
				2.ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
			Object.assign( )
				1.作用是生成元素，并且有宽高和背景
				2.当一个方法，有多个参数是可选的，并且没有顺序，通常是传一个对象
				3.Object.assign(target,[source1,source2....]);
			 		把多个对象的属性合并到第一个对象上
					返回值是目标对象
-------------------------------------------------------------------------------------------------------
8-24-25
	正则
		1.什么是正则？
			正则表达式，又称规则表达式。
			查找匹配某些符合规则的字符串，正则表达式就是写这种规则的工具。
			正则通常被用来检索、替换那些符合某个模式(规则)的文本。				
			正则只能作用在字符串上。
		2.定义正则表达式
			1. 字面量形式(推荐) 
				`/规则表达式/[修饰符]` 	
			 	规则表达式可以写普通的字符串，注意不要加引号 
			 2. 利用构造函数 
				new RegExp(规则(字符串),[修饰符]) 	
				规则存在一个变量中，要用构造函数的写法
		3.元字符
			转义符 \ 	
			\n 换行符 
			\'  一个单引号 
			\"  一个双引号 
			\t 制表符 一个tab 
			如果写两个反斜杠，转义再转义
		4.限定符
			限定符（量词）：匹配不确定的位置
				 +:至少出现一次，多者不限  {1,} 	
				 *:重复出现0次或多次  
				 {0,} 	
		 		 ?:0次或1次   {0,1} 
			 以上是规定好的，也可以自己定义 
				 n,m都是数字
					{n} 重复n次 	
					{n,} 至少重复n次，最多不限 	
					{n,m} 至少重复n次，最多重复m次

	正则方法：
		1.test( )方法
			正则去匹配字符串，如果匹配成功返回true，否则返回false;
			写法：正则.test(字符串)
			re.test(str) 
			作用
				用来检测指定的字符串是否符合正则的规则
 			语法
				boolean regexObj.test( string )
			参数
 				字符串 
 			返回值
				符合规则返回true，不符合返回false
		2.match()方法
			 str.match(str|re)	
			 作用
				检索指定字符串或正则表达式匹配到的字符串
			 语法
				Array | Null string.match ( string | regexObj )
			 参数
			 	string | regexObj
		 		字符串或正则表达式

				参数为regexObj时
					带有g，全局匹配，返回的是匹配到的字符串组成的数组
					不带g，匹配一个字符串，并且数组会有index和input属性
					index 是匹配到的字符的位置
					input 就是要检索的字符串
			 返回值
				返回数组---把匹配到的字符串放在数组中
			 	没有检索到返回null
			不会改变原字符串

			正则默认：正则匹配成功就会结束，不会继续匹配
			如果向全部查找，就要加标识g（global全局匹配）
			量词 + : 至少出现一次，多者不限

		3.search( ); 是字符串的方法，不是正则的方法
			 str.search(string|re);
			 作用
				检索指定字符串或正则表达式匹配到的字符串首次出现的位置
			 语法
				number string.search(string|regexObj)
			 参数
			 	string|regexObj
				字符串或正则表达式
			 返回值
				匹配到的字符串首次出现的位置
			 	没有检索到返回-1
			不会改变原字符串
			和indeOf()区别：indexOf()只能接收字符串作为参数,search()可以接受正则
		4.replace( )  是字符串的方法
			 str.replace(string|re)
			 作用
				用来替换字符串中的某些符合规则的字符
			 语法
				String string.replace(string|regexObj,string|function)
			 参数
				第一个参数：字符串或正则表达式
				第二个参数：字符串或函数
				在目标字符串中，每匹配到一次，就会调用一次该函数

				如果第二个参数是函数
					正则里有分组
						函数的形参：第一个是正则完整匹配到的字符（串），从第二个参数开始是分组的字符串，倒数第二个参数是完整匹配的字符的下标，倒数第一个参数是要搜索的字符串本身
					正则里没有分组
						函数的形参：第一个是正则匹配到的字符串，第二个是完整匹配的字符的下标，第三个是要搜索的字符串本身
			 返回值
				替换后新字符串
			不会改变原字符串
		5.^ 如果写在正则的开头，那么代表字符串的开始
		6.$ 表示字符串的结尾

		7.test( )的问题
			+   如果加了全局匹配，每匹配到一次就会记录这个位置的下一个位置（该位置的下标+1），下一次再调用就会从这个记录的位置再搜索
			oninput是标准浏览器 ie9以上 chrome ff
			onpropertychange 是低版本的

		8.分组
			( )
				在正则表达式中，称之为子项表达式或子项
				如果正则中有分组，在match的表现
					正则有g,不捕获分组的信息
					正则没有g,捕获分组信息

			?:  不捕获分组信息

		9.元字符

			 \d 代表一个数字
			 \D 代表一个非数字
			 \s 代表一个空格

			 \S 代表一个非空格
			 \w 字母、数字、_
			 \W 非字母、数字、_
			 \b 单词边界
			 \B 非单词边界
		   	 一个\w的左边或右边不是一个\w就有一个边界符
			. 任意字符 除了换行符 \n
			匹配 . [] {} () \ 使用转移符 \ 消除原有的意义
		10.单词边界
			\b 单词边界
			\B 非单词边界
			 一个\w的左边或右边不是\w，就有一个边界符
		11.贪婪模式
			let str = 'a123ca45abc6cmiaov';
			// 规则：a开始c结束，中间是数字字母下划线
			let re = /a\w+c/g;
			console.log(str.match(re));// ["a123ca45abc6c"]
		12.懒惰模式		
			let str = 'a123ca45abc6cmiaov';
			let re2 = /a\w+?c/g;
			console.log(str.match(re2));// ["a123c", "a45abc"]


-------------------------------------------------------------------------------------------------------
8-28
	全天：
		1.面向对象编程 oop,Object Oriented Programming，OOP，面向对象程序设计
		2.构造函数也就是一个普通的函数，作为构造函数，约定：作为构造函数，首字母大写
			构造函数：通过这个函数创建对象
			对象 普通对象 { }
			new 操作符
				调用函数，创建对象
			步骤：
				1. 会在构造函数的内部创建一个空对象
				2. 函数内部的this指向这个空对象（this就代表了这个对象）
				3. 执行函数，添加属性
				4. 返回这个对象
			显式的使用return
				return后后面的值是一个简单类型的值，return的是内部创建的对象
				return后后面的值是一个对象类型的值，返回的是return后面的这个对象
		3.构造函数的首字母大写是以约定，自己写的或看到别人写，使用new来调用；希望把一个函数作为构造函数，尽可能的首字母大写
		4.把一类对象共享的属性和方法，放在原型上
		5.prototype  原型
			每一个函数都拥有一个属性叫prototype，就是原型
			通过这个函数创建出来的一类对象拥有的共享的属性和方法，都放在放在这个函数的原型上
			原型对应的值是一个对象（默认是通过Object创建出来的）
			
		6.通过一个构造函数创建的对象和构造的原型有关系呢？？？
			__proto__
				每一个对象上都有办一个__proto__属性，值指向的是创建这个对象的构造函数的原型
			原型链
				一个对象查找一个属性的一套规则
				当查找一个属性，先从自身查找，继续找构造函数的原型，直到找到Object.prototype为止，没找到返回undefined
		7.	
			function Info(name){
				// 内建一个隐式的对象
				// this指向对象，this就是这个对象 
				//this = {};
				this.name = name;
				// 把内建的对象返回
			}
			// 通过这个构造函数创建的对象共享属性和方法，放在原型上
			// 共享的属性或方法之创建一次，节省内存空间
			//Info.prototype = { }
			Info.prototype.run = function(){
				console.log(this.name)
			}


			let i = new Info('leo');//创建的对象，实例，实例对象
			// 使用new调用后赋值给变量i，这个i和函数中this指向的是同一个对象
			i.run()
			console.log(i)
		8.对象上有一个__proto__属性，通过这个属性让对象和原型建立联系
			当i调用run方法的时候，首先先从自身找，自身没有，找构造这个i对象构造函数的原型上找，没找到，找创建原型对象的构造函数的原型上找，一直找object.prototype为止
-------------------------------------------------------------------------------------------------------
8-29
	全天：
		1. 给构造函数不传参，( )可以不写
		2. 通过一个构造函数可以创建一个对象
		3. 通过这个构造函数创建的一类对象拥有共享的属性和方法
		4. 把共享的方法放在函数的原型上 函数.prototype
		5. 当要访问函数原型的方法时候（对象和原型之间又怎样的联系）
		6.constructor
			函数的原型是一个对象，对象初始的时候有一个属性为constructor
			constructor的值指向的是拥有这个原型的函数
			constructor 可以被改写，所以判断一个对象属于哪个类型有问题
		7.原型重新赋了一个新的对象，手动的把constructor改回来
			Info.prototype = {
				constructor:Info
			}
		8.instanceOf （二元运算符）
			对象  instanceOf 函数

			描述有问题：
				简单理解：				
				运算一下这个函数是不是对象的构造函数
					是 结果为true
					不是 结果为false
			正确描述（待定）：
				运算一下函数的原型是不是在这这个对象的原型链上
		9.判断类型
			typeof
				数组和对象不能分辨出来
			constructor
				容易被改写
			instanceof
				找原型链上的函数
			Object.prototype.toString
				几乎完美
		10.对象.hasOwnProperty(属性名)
			判断属性名是不是对象自身的属性
			并不会找原型链上的
			for in 遍历一个对象上的属性
				去找原型链上的属性
			当只遍历自身属性加上 hasOwnProperty
		11.Object.getOwnPropertyDescriptor( ) 方法返回指定对象上一个自有属性对应的属性描述符。
			（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
			function Info(){
				this.abc = 10;
			}
			//得到constructor的描述符，不被遍历的
			console.log(Object.getOwnPropertyDescriptor(Info.prototype,"constructor"))
			//Object {writable: true, enumerable: false, configurable: true, value: function}

-------------------------------------------------------------------------------------------------------
8-30
	全天：
		1.当在多个原型上的方法，使用同一个属性的时候，通常是把这个属性放在对象上
		2.new 调用一个函数做了什么？ 
                		1. 函数的内部创建隐式的对象  （添加属性的）
               			2. 函数中this=>隐式的对象   (通过this给对象添加属性)
                		3. 执行函数 
               			4. 把隐式的对象返回出去
		
			1. new Drag 之后 会在Drag函数内部创建一个对象（yinshiObj）
            			2. Drag函数中this => yinshiObj
            			3. 把yinshiObj返回出来了
            			4. 把yinshiObj赋值给了变量d
            			5. d.init()调用，init函数中this => yinshiObj
		3.
			let obj = {
                		           fn:function(){
                    			console.log(this);
                		           }
           			 }
            			// 通过obj的属性fn取出函数之后直接执行了函数，函数中this指向的是obj，
			// fn是通过obj调用的，this就指向obj
           			obj.fn( );//Object {fn: function}

           			let f = obj.fn;
            			//相当于
           			let f = function(){
                			console.log(this)
            			}
            			// 直接调用函数，this=> window
            			f( ) //Window {stop: function, open: function, alert: function, confirm: function, prompt: function…}
		4.判断一个函数有没有使用bind
			let obj2 = {
                			fn:function(){
                    				console.log(this)
                			}
            			}
           	 		let a1 = obj2.fn;
            			let a2 = obj2.fn.bind([1,2,3])// 改变函数this但是不直接执行
            			//判断一个函数有没有使用bind（只能原生的有用）
            			console.log(a1.name);  //fn
            			console.log(a2.name);  //bound fn
		5.包装对象
			String( )
			Number( )
			Boolean( )
		                对象都是数据，数据不一定都是对象
			只有对象才有属性
			let str2 = new String( 'miaov' );
			console.log( str2.slice );
			console.log( str2.valueOf( ) );  // 拿到原始值
		6.继承
			构造函数（类式继承）
				call或apply
			拷贝继承
				把父类原型上的属性拷贝到子级原型上
				Object.assign(Coder.prototype,People.prototype)
			原型继承 ( 加长原型链 )
				a. 直接把Coder.prototype改写为 People.prototype;
				因为此时Coder.prototype和 People.prototype用的是同一个对象,所以使用Coder.prototype添加属性的时候，影响了People.prototype，实不可取的
				b. Coder.prototype = new People;
			寄生式继承，中间的一个类;
            				function F( ){ };
            				F.prototype = People.prototype;// 把父类的原型给到中间类
            				Coder.prototype = new F;// 改写子类的原型为中间类生成的对象
            				Coder.prototype.constructor = Coder;// 把子类的constructor指回到子类
		7.使用关键字class来定义类
			子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。
		  	当不传值的时候，类中可以不用写constructor
			super作为函数，就是构造函数
			

-------------------------------------------------------------------------------------------------------
8-31
	全天：
		1.









	